local LoadingTick = os.clock()

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/i77lhm/Libraries/refs/heads/main/Utopia/Library.lua"))()



do
    local getinfo = getinfo or debug.getinfo
    local DEBUG = false
    local Hooked = {}

    local Detected, Kill

    setthreadidentity(2)

    for i, v in getgc(true) do
        if typeof(v) == "table" then
            local DetectFunc = rawget(v, "Detected")
            local KillFunc = rawget(v, "Kill")
        
            if typeof(DetectFunc) == "function" and not Detected then
                Detected = DetectFunc
                
                local Old; Old = hookfunction(Detected, function(Action, Info, NoCrash)
                    if Action ~= "_" then
                        if DEBUG then
                            warn(`Adonis AntiCheat flagged\nMethod: {Action}\nInfo: {Info}`)
                        end
                    end
                    
                    return true
                end)

                table.insert(Hooked, Detected)
            end

            if rawget(v, "Variables") and rawget(v, "Process") and typeof(KillFunc) == "function" and not Kill then
                Kill = KillFunc
                local Old; Old = hookfunction(Kill, function(Info)
                    if DEBUG then
                        warn(`Adonis AntiCheat tried to kill (fallback): {Info}`)
                    end
                end)

                table.insert(Hooked, Kill)
            end
        end
    end

    local Old; Old = hookfunction(getrenv().debug.info, newcclosure(function(...)
        local LevelOrFunc, Info = ...

        if Detected and LevelOrFunc == Detected then
            if DEBUG then
                warn(`zins | adonis bypassed`)
            end

            return coroutine.yield(coroutine.running())
        end
        
        return Old(...)
    end))

    setthreadidentity(7)
end




local Window = Library:Window({
    Name = "offset.universal (flick)",
    GradientTitle = {
        Enabled = true,
        Start = Color3.fromRGB(255, 255, 255),
        Middle = Color3.fromRGB(0, 251, 255),
        End = Color3.fromRGB(50, 135, 168),
        Speed = 1
    }
})

local Watermark = Library:Watermark("idk bruh", {"77974153657891", Color3.fromRGB(149, 255, 139)})
local KeybindList = Library:KeybindList()

Watermark:SetVisibility(false)
KeybindList:SetVisibility(false)

local CombatTab   = Window:Page({Name = "Combat",   Columns = 2 })
local MiscTab     = Window:Page({Name = "Misc",     Columns = 2 })
local VisualsTab  = Window:Page({Name = "Visuals",  Columns = 2 })
local SettingsTab = Window:Page({Name = "Settings", Columns = 2 })

-- [SILENT AIM]
do
    local Players           = game:GetService("Players")
    local RunService        = game:GetService("RunService")
    local Workspace         = game:GetService("Workspace")
    local LocalPlayer       = Players.LocalPlayer
    local Camera            = Workspace.CurrentCamera

    local SETTINGS = {
        ENABLED         = false,
        TEAM_CHECK      = false,
        FOV             = 120,
        HIT_CHANCE      = 100,
        TRACER_COLOR    = Color3.fromRGB(0,255,0),
        TRACER_THICK    = 3,
        TRACER_VISIBLE  = true
    }

    local ClientRemotes = LocalPlayer:WaitForChild("ClientRemotes", 5)
    local CheckShot     = ClientRemotes and ClientRemotes:FindFirstChild("CheckShot")
    if not CheckShot then error("[TARGET-AIM] Could not find CheckShot remote!") end

    local fovCircle = Drawing.new("Circle")
    fovCircle.Visible   = false
    fovCircle.Thickness = 2
    fovCircle.Color     = Color3.fromRGB(255,0,0)
    fovCircle.Filled    = false
    fovCircle.Radius    = SETTINGS.FOV
    fovCircle.NumSides  = 64
    fovCircle.Transparency = 1

    local tracerLine = Drawing.new("Line")
    tracerLine.Visible      = false
    tracerLine.Color        = SETTINGS.TRACER_COLOR
    tracerLine.Thickness    = SETTINGS.TRACER_THICK
    tracerLine.Transparency = 1

    local currentTarget = nil

    local function getClosestPart()
        local bestPart = nil
        local bestDist = math.huge
        local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

        for _, plr in Players:GetPlayers() do
            if plr == LocalPlayer or (SETTINGS.TEAM_CHECK and plr.Team == LocalPlayer.Team) then continue end
            local char = plr.Character
            if not char then continue end
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hum or hum.Health <= 0 then continue end

            for _, partName in {"Head", "UpperTorso", "HumanoidRootPart"} do
                local part = char:FindFirstChild(partName)
                if part then
                    local scr, onScreen = Camera:WorldToViewportPoint(part.Position)
                    if onScreen then
                        local dist = (Vector2.new(scr.X, scr.Y) - screenCenter).Magnitude
                        if dist <= SETTINGS.FOV and dist < bestDist then
                            bestDist = dist
                            bestPart = part
                        end
                    end
                end
            end
        end
        return bestPart
    end

    RunService.Heartbeat:Connect(function()
        if not SETTINGS.ENABLED then
            currentTarget = nil
            tracerLine.Visible = false
            return
        end

        local newTarget = getClosestPart()
        if newTarget then currentTarget = newTarget end

        fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        fovCircle.Radius = SETTINGS.FOV

        if currentTarget then
            local camPos = Camera.CFrame.Position
            local targPos = currentTarget.Position

            local fromScr, fromOn = Camera:WorldToViewportPoint(camPos)
            local toScr,   toOn   = Camera:WorldToViewportPoint(targPos)

            local fromVec = fromOn and Vector2.new(fromScr.X, fromScr.Y)
                            or Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

            local toVec = toOn and Vector2.new(toScr.X, toScr.Y)
                          or Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

            tracerLine.From = fromVec
            tracerLine.To   = toVec
            tracerLine.Visible = SETTINGS.TRACER_VISIBLE
        else
            tracerLine.Visible = false
        end
    end)

    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)

    mt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()
        local args = {...}

        if self == CheckShot and method == "FireServer" and SETTINGS.ENABLED and currentTarget then
            if math.random(1,100) <= SETTINGS.HIT_CHANCE then
                args[6] = currentTarget.Position
                args[7] = currentTarget
            end
        end

        return oldNamecall(self, unpack(args))
    end)

    setreadonly(mt, true)

    local AimbotSection = CombatTab:Section({Name = "Silentaim", Side = 1})

    AimbotSection:Toggle({
        Name = "Silent Aim",
        Flag = "SilentAim_Enabled",
        Default = false,
        Callback = function(v)
            SETTINGS.ENABLED = v
            fovCircle.Visible = v
            currentTarget = nil
        end
    }):Keybind({
        Name = "Silent Aim Keybind",
        Flag = "SilentAim_Keybind",
        Default = Enum.KeyCode.Insert,
        Mode = "Toggle",
        Callback = function(v)
            SETTINGS.ENABLED = v
            fovCircle.Visible = v
            currentTarget = nil
        end
    })

    AimbotSection:Slider({
        Name = "FOV",
        Min = 30,
        Max = 500,
        Default = 120,
        Increment = 5,
        Flag = "SilentAim_FOV",
        Callback = function(v)
            SETTINGS.FOV = v
        end
    })

    AimbotSection:Label("Circle Color", "Left"):Colorpicker({
        Name = "FOV Color",
        Flag = "SilentAim_FOVColor",
        Default = Color3.fromRGB(255, 0, 0),
        Callback = function(Color, Alpha)
            fovCircle.Color = Color
            fovCircle.Transparency = 1 - (Alpha or 1)
        end
    })

    AimbotSection:Toggle({
        Name = "Tracer Visual",
        Flag = "SilentAim_TracerVisible",
        Default = true,
        Callback = function(v)
            SETTINGS.TRACER_VISIBLE = v
        end
    })

    AimbotSection:Label("Tracer Color", "Left"):Colorpicker({
        Name = "Tracer Color",
        Flag = "SilentAim_TracerColor",
        Default = Color3.fromRGB(0, 255, 0),
        Callback = function(Color, Alpha)
            tracerLine.Color = Color
            tracerLine.Transparency = 1 - (Alpha or 1)
        end
    })

    task.spawn(function()
        while task.wait(0.1) do
            if Library.Flags["SilentAim_FOVColor"] and Library.Flags["SilentAim_TracerColor"] then
                local fovCol = Library.Flags["SilentAim_FOVColor"].Color
                local fovAlpha = Library.Flags["SilentAim_FOVColor"].Alpha or 1
                fovCircle.Color = fovCol
                fovCircle.Transparency = 1 - fovAlpha

                local tracerCol = Library.Flags["SilentAim_TracerColor"].Color
                local tracerAlpha = Library.Flags["SilentAim_TracerColor"].Alpha or 1
                tracerLine.Color = tracerCol
                tracerLine.Transparency = 1 - tracerAlpha

                break
            end
        end
    end)
end

-- [TRACER]
do
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local TweenService = game:GetService("TweenService")
    local Debris = game:GetService("Debris")
    local UserInputService = game:GetService("UserInputService")
    local LocalPlayer = Players.LocalPlayer

    local success, bulletTemplate = pcall(function()
        return ReplicatedStorage.ModuleScripts.GunModules.Tracer["Projectile's"].Bullet
    end)
    local templateName = (success and bulletTemplate) and bulletTemplate.Name or nil

    local SETTINGS = {
        ENABLED = false,
        TRACER_THICKNESS = 0.12,
        TRACER_LENGTH = 50,
        TRACER_FADE_TIME = 2,
        TRACE_MAX_DISTANCE = 3000,
        TRACER_COLOR = Color3.fromRGB(255,255,255)
    }

    local tracerConnection = nil
    local clickConnection = nil

    local function GetLocalMuzzlePosition()
        local function findInTool(tool)
            if not tool then return nil end
            local muz = tool:FindFirstChild("Muz") or tool:FindFirstChild("Muzzle") or tool:FindFirstChild("Barrel")
            if muz then
                local loc = muz:FindFirstChild("LOC") or muz:FindFirstChild("Loc")
                if loc then
                    if loc:IsA("Attachment") then return loc.WorldPosition end
                    if loc:IsA("BasePart") then return loc.Position end
                end
                if muz:IsA("BasePart") then return muz.Position end
            end
            local handle = tool:FindFirstChild("Handle")
            if handle and handle:IsA("BasePart") then return handle.Position end
            return nil
        end
        local bp = LocalPlayer:FindFirstChild("Backpack")
        if bp then
            local t = bp:FindFirstChild("Sniper") or bp:FindFirstChildWhichIsA("Tool")
            if t then
                local v = findInTool(t)
                if v then return v end
            end
        end
        if LocalPlayer.Character then
            local t = LocalPlayer.Character:FindFirstChild("Sniper") or LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
            if t then
                local v = findInTool(t)
                if v then return v end
            end
        end
        return nil
    end

    local function ResolveRoot(obj)
        if not obj then return nil end
        if obj:IsA("Model") then return obj end
        if obj:IsA("BasePart") then
            local p = obj.Parent
            while p and not p:IsA("Workspace") do
                if p:IsA("Model") then return p end
                p = p.Parent
            end
            return obj
        end
        return nil
    end

    local function GetRootPosition(root)
        if not root then return nil end
        if root:IsA("BasePart") then return root.Position end
        if root.PrimaryPart and root.PrimaryPart:IsA("BasePart") then return root.PrimaryPart.Position end
        for _,c in ipairs(root:GetDescendants()) do
            if c:IsA("BasePart") then return c.Position end
        end
        return nil
    end

    local function IsOwnedByMe(root)
        if not root then return false end
        if LocalPlayer.Character and root:IsDescendantOf(LocalPlayer.Character) then return true end
        for _, name in ipairs({"creator","Creator","owner","Owner","Shooter","Player"}) do
            local v = root:FindFirstChild(name, true)
            if v then
                local ok, val = pcall(function() return v.Value end)
                if ok and val == LocalPlayer then return true end
            end
        end
        return false
    end

    local function CreateTracer(startPos, endPos)
        if not startPos or not endPos then return end
        local dir = endPos - startPos
        local dist = dir.Magnitude
        if dist <= 0.01 then return end
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = SETTINGS.TRACER_COLOR
        part.Size = Vector3.new(SETTINGS.TRACER_THICKNESS, SETTINGS.TRACER_THICKNESS, math.min(dist, SETTINGS.TRACER_LENGTH))
        part.CFrame = CFrame.new(startPos, endPos) * CFrame.new(0, 0, -part.Size.Z/2)
        part.Parent = Workspace
        part.Transparency = 0
        TweenService:Create(part, TweenInfo.new(SETTINGS.TRACER_FADE_TIME), {Transparency = 1}):Play()
        Debris:AddItem(part, SETTINGS.TRACER_FADE_TIME + 0.1)
    end

    local function ComputeEndPointFrom(startPos)
        local cam = Workspace.CurrentCamera
        if not cam then return startPos end
        local dir = cam.CFrame.LookVector * SETTINGS.TRACE_MAX_DISTANCE
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = { LocalPlayer.Character }
        params.FilterType = Enum.RaycastFilterType.Exclude
        local hit = Workspace:Raycast(startPos, dir, params)
        if hit then return hit.Position end
        return startPos + cam.CFrame.LookVector * SETTINGS.TRACER_LENGTH
    end

    local function StartTracer()
        if tracerConnection then tracerConnection:Disconnect() end
        if clickConnection then clickConnection:Disconnect() end

        tracerConnection = Workspace.DescendantAdded:Connect(function(obj)
            if not SETTINGS.ENABLED or not obj or not obj:IsDescendantOf(Workspace) then return end
            local root = ResolveRoot(obj)
            if not root then return end
            if templateName and root.Name ~= templateName and obj.Name ~= templateName then return end
            task.delay(0.01, function()
                local pos = GetRootPosition(root)
                if not pos then return end
                if not IsOwnedByMe(root) then return end
                local muzzle = GetLocalMuzzlePosition()
                local startPos = muzzle or pos
                local endPos = ComputeEndPointFrom(startPos)
                CreateTracer(startPos, endPos)
            end)
        end)

        clickConnection = UserInputService.InputBegan:Connect(function(input, gpe)
            if not SETTINGS.ENABLED or gpe then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local muzzle = GetLocalMuzzlePosition()
                local cam = Workspace.CurrentCamera
                if muzzle and cam then
                    CreateTracer(muzzle, muzzle + cam.CFrame.LookVector * SETTINGS.TRACER_LENGTH)
                end
            end
        end)
    end

    local function StopTracer()
        if tracerConnection then tracerConnection:Disconnect() tracerConnection = nil end
        if clickConnection then clickConnection:Disconnect() clickConnection = nil end
    end

    local TracerSection = VisualsTab:Section({Name = "Tracer", Side = 1})

    TracerSection:Toggle({
        Name = "Tracer",
        Flag = "WhiteTracer_Enabled",
        Default = false,
        Callback = function(v)
            SETTINGS.ENABLED = v
            if v then
                StartTracer()
            else
                StopTracer()
            end
        end
    })

    TracerSection:Label("Tracer Color", "Left"):Colorpicker({
        Name = "Tracer Color",
        Flag = "WhiteTracer_Color",
        Default = Color3.fromRGB(255, 255, 255),
        Callback = function(Color, Alpha)
            SETTINGS.TRACER_COLOR = Color
        end
    })

    task.spawn(function()
        while task.wait(0.1) do
            if Library.Flags["WhiteTracer_Color"] then
                SETTINGS.TRACER_COLOR = Library.Flags["WhiteTracer_Color"].Color
                break
            end
        end
    end)
end

-- [FORCE FOV]
do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    local LocalPlayer = Players.LocalPlayer
    local Camera = Workspace.CurrentCamera

    local SETTINGS = {
        ENABLED = false,
        FORCED_FOV = 120
    }

    local fovConnection = nil
    local renderConnection = nil

    local function StartFOV()
        if fovConnection then fovConnection:Disconnect() end
        if renderConnection then renderConnection:Disconnect() end

        fovConnection = Camera:GetPropertyChangedSignal("FieldOfView"):Connect(function()
            if SETTINGS.ENABLED then
                Camera.FieldOfView = SETTINGS.FORCED_FOV
            end
        end)

        renderConnection = RunService.RenderStepped:Connect(function()
            if SETTINGS.ENABLED and Camera.FieldOfView ~= SETTINGS.FORCED_FOV then
                Camera.FieldOfView = SETTINGS.FORCED_FOV
            end
        end)

        if SETTINGS.ENABLED then
            Camera.FieldOfView = SETTINGS.FORCED_FOV
        end
    end

    local function StopFOV()
        if fovConnection then fovConnection:Disconnect() fovConnection = nil end
        if renderConnection then renderConnection:Disconnect() renderConnection = nil end
    end

    local FOVSection = VisualsTab:Section({Name = "FOV", Side = 2})

    FOVSection:Toggle({
        Name = "FOV",
        Flag = "ForceFOV_Enabled",
        Default = false,
        Callback = function(v)
            SETTINGS.ENABLED = v
            StartFOV()
            if not v then
                StopFOV()
            end
        end
    })

    FOVSection:Slider({
        Name = "FOV Value",
        Min = 0,
        Max = 120,
        Default = 120,
        Increment = 1,
        Flag = "ForceFOV_Value",
        Callback = function(v)
            SETTINGS.FORCED_FOV = v
        end
    })

    task.spawn(function()
        while task.wait(0.1) do
            if Library.Flags["ForceFOV_Value"] then
                SETTINGS.FORCED_FOV = Library.Flags["ForceFOV_Value"]
                break
            end
        end
    end)
end

-- [FORCE 3RD PERSON] — Toggle only
do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    local LocalPlayer = Players.LocalPlayer
    local Camera = Workspace.CurrentCamera

    local SETTINGS = {
        ENABLED = false,
        MIN_ZOOM = 10.5,
        MAX_ZOOM = 400
    }

    local connections = {}

    local function applyThirdPerson()
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Humanoid") then return end

        LocalPlayer.CameraMode = Enum.CameraMode.Classic
        LocalPlayer.CameraMinZoomDistance = SETTINGS.MIN_ZOOM
        LocalPlayer.CameraMaxZoomDistance = SETTINGS.MAX_ZOOM
        Camera.CameraType = Enum.CameraType.Custom
    end

    local function StartThirdPerson()
        for _, conn in ipairs(connections) do
            if conn.Connected then conn:Disconnect() end
        end
        table.clear(connections)

        table.insert(connections, LocalPlayer.CharacterAdded:Connect(applyThirdPerson))
        if LocalPlayer.Character then applyThirdPerson() end

        table.insert(connections, RunService.RenderStepped:Connect(function()
            if SETTINGS.ENABLED then
                if LocalPlayer.CameraMode ~= Enum.CameraMode.Classic then
                    LocalPlayer.CameraMode = Enum.CameraMode.Classic
                end
                if LocalPlayer.CameraMinZoomDistance ~= SETTINGS.MIN_ZOOM then
                    LocalPlayer.CameraMinZoomDistance = SETTINGS.MIN_ZOOM
                end
                if LocalPlayer.CameraMaxZoomDistance ~= SETTINGS.MAX_ZOOM then
                    LocalPlayer.CameraMaxZoomDistance = SETTINGS.MAX_ZOOM
                end
                if Camera.CameraType ~= Enum.CameraType.Custom then
                    Camera.CameraType = Enum.CameraType.Custom
                end
            end
        end))

        table.insert(connections, LocalPlayer:GetPropertyChangedSignal("CameraMode"):Connect(function()
            if SETTINGS.ENABLED and LocalPlayer.CameraMode ~= Enum.CameraMode.Classic then
                LocalPlayer.CameraMode = Enum.CameraMode.Classic
            end
        end))

        local devProps = {"DevComputerCameraMode", "DevTouchCameraMode", "DevCameraOcclusionMode"}
        for _, prop in ipairs(devProps) do
            table.insert(connections, LocalPlayer:GetPropertyChangedSignal(prop):Connect(function()
                task.defer(function()
                    if SETTINGS.ENABLED then
                        LocalPlayer.CameraMode = Enum.CameraMode.Classic
                    end
                end)
            end))
        end

        if SETTINGS.ENABLED then applyThirdPerson() end
    end

    local function StopThirdPerson()
        for _, conn in ipairs(connections) do
            if conn.Connected then conn:Disconnect() end
        end
        table.clear(connections)
    end

    local ThirdPersonSection = VisualsTab:Section({Name = "3rd Person", Side = 1})

    ThirdPersonSection:Toggle({
        Name = "3rd Person",
        Flag = "Force3rdPerson_Enabled",
        Default = false,
        Callback = function(v)
            SETTINGS.ENABLED = v
            if v then
                StartThirdPerson()
            else
                StopThirdPerson()
            end
        end
    })
end

-- [SPIN BOT] — In Misc Tab
do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer

    local SETTINGS = {
        ENABLED = false,
        SPEED = 5
    }

    local spinConnection = nil

    local function StartSpin()
        if spinConnection then spinConnection:Disconnect() end

        spinConnection = RunService.Heartbeat:Connect(function(dt)
            if not SETTINGS.ENABLED then return end
            local char = LocalPlayer.Character
            if not char then return end
            local root = char:FindFirstChild("HumanoidRootPart")
            if not root then return end

            root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(SETTINGS.SPEED), 0)
        end)
    end

    local function StopSpin()
        if spinConnection then
            spinConnection:Disconnect()
            spinConnection = nil
        end
    end

    local SpinSection = MiscTab:Section({Name = "Spin Bot", Side = 1})

    SpinSection:Toggle({
        Name = "Spin Bot",
        Flag = "SpinBot_Enabled",
        Default = false,
        Callback = function(v)
            SETTINGS.ENABLED = v
            if v then
                StartSpin()
            else
                StopSpin()
            end
        end
    })

    SpinSection:Slider({
        Name = "Spin Speed",
        Min = 1,
        Max = 20,
        Default = 5,
        Increment = 1,
        Flag = "SpinBot_Speed",
        Callback = function(v)
            SETTINGS.SPEED = v
        end
    })
end

-- [CUSTOM AMBIENT] — TOGGLE + COLOR PICKER
do
    local Lighting = game:GetService("Lighting")

    local SETTINGS = {
        ENABLED = false,
        AMBIENT = Color3.fromRGB(255, 255, 255)
    }

    local AmbientSection = VisualsTab:Section({Name = "Ambience", Side = 2})

    AmbientSection:Toggle({
        Name = "Ambience",
        Flag = "Ambient_Enabled",
        Default = false,
        Callback = function(v)
            SETTINGS.ENABLED = v
            if v then
                Lighting.Ambient = SETTINGS.AMBIENT
            else
                Lighting.Ambient = Color3.fromRGB(163, 162, 162) -- Roblox default
            end
        end
    })

    AmbientSection:Label("Ambience Color", "Left"):Colorpicker({
        Name = "Color",
        Flag = "Ambient_Color",
        Default = Color3.fromRGB(255, 255, 255),
        Callback = function(Color)
            SETTINGS.AMBIENT = Color
            if SETTINGS.ENABLED then
                Lighting.Ambient = Color
            end
        end
    })

    task.spawn(function()
        while task.wait(0.1) do
            if Library.Flags["Ambient_Color"] then
                SETTINGS.AMBIENT = Library.Flags["Ambient_Color"].Color
                if SETTINGS.ENABLED then
                    Lighting.Ambient = SETTINGS.AMBIENT
                end
                break
            end
        end
    end)
end

-- [THEMES & CONFIGS]
local ThemesSection = SettingsTab:Section({ Name = "Settings", Side = 1 })
do
    for Index, Value in Library.Theme do
        Library.ThemeColorpickers[Index] = ThemesSection:Label(Index, "Left"):Colorpicker({
            Name = Index,
            Flag = "Theme" .. Index,
            Default = Value,
            Callback = function(Value)
                Library.Theme[Index] = Value
                Library:ChangeTheme(Index, Value)
            end
        })
    end

    ThemesSection:Dropdown({
        Name = "Themes list",
        Items = {"Default", "Bitchbot", "Onetap", "Aqua"},
        Default = "Default",
        Callback = function(Value)
            local ThemeData = Library.Themes[Value]
            if not ThemeData then return end
            for Index, Value in Library.Theme do
                Library.Theme[Index] = ThemeData[Index]
                Library:ChangeTheme(Index, ThemeData[Index])
                Library.ThemeColorpickers[Index]:Set(ThemeData[Index])
            end
            task.wait(0.3)
            Library:Thread(function()
                for Index, Value in Library.Theme do
                    Library.Theme[Index] = Library.Flags["Theme"..Index].Color
                    Library:ChangeTheme(Index, Library.Flags["Theme"..Index].Color)
                end
            end)
        end
    })

    local ThemeName, SelectedTheme
    local ThemesListbox = ThemesSection:Listbox({
        Name = "Themes List",
        Flag = "Themes List",
        Items = { },
        Multi = false,
        Default = nil,
        Callback = function(Value) SelectedTheme = Value end
    })

    ThemesSection:Textbox({
        Name = "Name",
        Flag = "Theme Name",
        Default = "",
        Placeholder = ". . .",
        Callback = function(Value) ThemeName = Value end
    })

    ThemesSection:Button({
        Name = "Save Theme",
        Callback = function()
            if ThemeName == "" or isfile(Library.Folders.Themes .. "/" .. ThemeName .. ".json") then
                Library:Notification("Invalid or existing theme name", 3, Color3.fromRGB(255, 0, 0))
                return
            end
            writefile(Library.Folders.Themes .. "/" .. ThemeName .. ".json", Library:GetTheme())
            Library:RefreshThemeList(ThemesListbox)
        end
    }):SubButton({
        Name = "Load Theme",
        Callback = function()
            if SelectedTheme then
                Library:LoadTheme(readfile(Library.Folders.Themes .. "/" .. SelectedTheme))
            end
        end
    })

    ThemesSection:Button({
        Name = "Refresh Themes",
        Callback = function() Library:RefreshThemeList(ThemesListbox) end
    })

    Library:RefreshThemeList(ThemesListbox)
end

local ConfigsSection = SettingsTab:Section({ Name = "Configs", Side = 2 })
do
    local ConfigName, SelectedConfig
    local ConfigsListbox = ConfigsSection:Listbox({
        Name = "Configs list",
        Flag = "Configs List",
        Items = { },
        Multi = false,
        Default = nil,
        Callback = function(Value) SelectedConfig = Value end
    })

    ConfigsSection:Textbox({
        Name = "Name",
        Flag = "Config Name",
        Default = "",
        Placeholder = ". . .",
        Callback = function(Value) ConfigName = Value end
    })

    ConfigsSection:Button({
        Name = "Load Config",
        Callback = function()
            if SelectedConfig then
                Library:LoadConfig(readfile(Library.Folders.Configs .. "/" .. SelectedConfig))
                Library:Thread(function()
                    task.wait(0.1)
                    for Index, _ in Library.Theme do
                        Library.Theme[Index] = Library.Flags["Theme"..Index].Color
                        Library:ChangeTheme(Index, Library.Flags["Theme"..Index].Color)
                    end
                end)
            end
        end
    }):SubButton({
        Name = "Save Config",
        Callback = function()
            if SelectedConfig then Library:SaveConfig(SelectedConfig) end
        end
    })

    ConfigsSection:Button({
        Name = "Create Config",
        Callback = function()
            if ConfigName == "" or isfile(Library.Folders.Configs .. "/" .. ConfigName .. ".json") then
                Library:Notification("Invalid or existing config name", 3, Color3.fromRGB(255, 0, 0))
                return
            end
            writefile(Library.Folders.Configs .. "/" .. ConfigName .. ".json", Library:GetConfig())
            Library:RefreshConfigsList(ConfigsListbox)
        end
    }):SubButton({
        Name = "Delete Config",
        Callback = function()
            if SelectedConfig then
                Library:DeleteConfig(SelectedConfig)
                Library:RefreshConfigsList(ConfigsListbox)
            end
        end
    })

    ConfigsSection:Button({
        Name = "Refresh Configs",
        Callback = function() Library:RefreshConfigsList(ConfigsListbox) end
    })

    Library:RefreshConfigsList(ConfigsListbox)

    ConfigsSection:Label("Menu Keybind", "Left"):Keybind({
        Name = "Menu Keybind",
        Flag = "Menu Keybind",
        Default = Enum.KeyCode.RightControl,
        Mode = "Toggle",
        Callback = function(Value)
            Library.MenuKeybind = Library.Flags["Menu Keybind"].Key
        end
    })

    ConfigsSection:Toggle({
        Name = "Watermark",
        Flag = "Watermark",
        Default = false,
        Callback = function(Value)
            Watermark:SetVisibility(Value)
        end
    })

    ConfigsSection:Toggle({
        Name = "Keybind List",
        Flag = "Keybind List",
        Default = false,
        Callback = function(Value)
            KeybindList:SetVisibility(Value)
        end
    })

    ConfigsSection:Dropdown({
        Name = "Style",
        Flag = "Tweening Style",
        Default = "Exponential",
        Items = {"Linear", "Sine", "Quad", "Cubic", "Quart", "Quint", "Exponential", "Circular", "Back", "Elastic", "Bounce"},
        Callback = function(Value) Library.Tween.Style = Enum.EasingStyle[Value] end
    })

    ConfigsSection:Dropdown({
        Name = "Direction",
        Flag = "Tweening Direction",
        Default = "Out",
        Items = {"In", "Out", "InOut"},
        Callback = function(Value) Library.Tween.Direction = Enum.EasingDirection[Value] end
    })

    ConfigsSection:Slider({
        Name = "Tweening Time",
        Min = 0, Max = 5, Default = 0.25, Decimals = 0.01,
        Flag = "Tweening Time",
        Callback = function(Value) Library.Tween.Time = Value end
    })

    ConfigsSection:Button({
        Name = "Notification test",
        Callback = function()
            Library:Notification("Test notification!", 5, Color3.fromRGB(math.random(0,255), math.random(0,255), math.random(0,255)))
        end
    })

    ConfigsSection:Button({
        Name = "Unload library",
        Callback = function() Library:Unload() end
    })
end

Library:Notification("Loaded in " .. string.format("%.4f", os.clock() - LoadingTick) .. "s", 5, Color3.fromRGB(0, 255, 0))
